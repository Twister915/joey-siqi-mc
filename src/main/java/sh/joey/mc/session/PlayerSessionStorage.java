package sh.joey.mc.session;

import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import sh.joey.mc.storage.StorageService;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.UUID;

/**
 * Handles persistence of player sessions to PostgreSQL.
 * All operations are async and return RxJava types.
 */
public final class PlayerSessionStorage {

    private final StorageService storage;

    public PlayerSessionStorage(StorageService storage) {
        this.storage = storage;
    }

    /**
     * Record a player joining the server.
     * The session id is auto-generated by the database.
     */
    public Completable recordJoin(UUID playerId, String username, String remoteIp,
                                   boolean onlineMode, UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                INSERT INTO player_sessions (player_id, username, remote_ip, online_mode, server_session_id)
                VALUES (?, ?, ?, ?, ?)
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);
                stmt.setString(2, username);
                stmt.setString(3, remoteIp);
                stmt.setBoolean(4, onlineMode);
                stmt.setObject(5, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Update last_seen_at for all active sessions belonging to this server run.
     * Called periodically as a heartbeat.
     */
    public Completable updateLastSeen(UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                UPDATE player_sessions
                SET last_seen_at = NOW()
                WHERE server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Record a player disconnecting from the server.
     */
    public Completable recordDisconnect(UUID playerId, UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                UPDATE player_sessions
                SET disconnected_at = NOW(), last_seen_at = NOW()
                WHERE player_id = ? AND server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);
                stmt.setObject(2, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Fix orphaned sessions from previous server runs (e.g., after a crash).
     * Sets disconnected_at = last_seen_at for any sessions not belonging to the current server.
     * Uses queryBlocking() so it's safe to call .blockingGet() from the main thread.
     *
     * @return a Single emitting the number of orphaned sessions that were fixed
     */
    public Single<Integer> fixOrphanedSessions(UUID currentServerSessionId) {
        return storage.queryBlocking(conn -> {
            String sql = """
                UPDATE player_sessions
                SET disconnected_at = last_seen_at
                WHERE server_session_id != ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, currentServerSessionId);
                return stmt.executeUpdate();
            }
        });
    }

    /**
     * Find a player's UUID by their username (case-insensitive).
     * Returns the player_id from their most recent session.
     */
    public Maybe<UUID> findPlayerIdByName(String username) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT player_id
                FROM player_sessions
                WHERE LOWER(username) = LOWER(?)
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, username);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getObject("player_id", UUID.class);
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Find a player's username by their UUID.
     * Returns the username from their most recent session.
     */
    public Maybe<String> findUsernameById(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT username
                FROM player_sessions
                WHERE player_id = ?
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getString("username");
                    }
                    return null;
                }
            }
        });
    }
}
