package sh.joey.mc.session;

import io.reactivex.rxjava3.core.Completable;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Single;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import sh.joey.mc.storage.StorageService;

import org.jetbrains.annotations.Nullable;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Handles persistence of player sessions to PostgreSQL.
 * All operations are async and return RxJava types.
 */
public final class PlayerSessionStorage {

    private final StorageService storage;

    public PlayerSessionStorage(StorageService storage) {
        this.storage = storage;
    }

    /**
     * Record a player joining the server.
     * The session id is auto-generated by the database.
     */
    public Completable recordJoin(UUID playerId, String username, String remoteIp,
                                   boolean onlineMode, UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                INSERT INTO player_sessions (player_id, username, remote_ip, online_mode, server_session_id)
                VALUES (?, ?, ?, ?, ?)
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);
                stmt.setString(2, username);
                stmt.setString(3, remoteIp);
                stmt.setBoolean(4, onlineMode);
                stmt.setObject(5, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Update last_seen_at for all active sessions belonging to this server run.
     * Called periodically as a heartbeat.
     */
    public Completable updateLastSeen(UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                UPDATE player_sessions
                SET last_seen_at = NOW()
                WHERE server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Record a player disconnecting from the server.
     */
    public Completable recordDisconnect(UUID playerId, UUID serverSessionId) {
        return storage.execute(conn -> {
            String sql = """
                UPDATE player_sessions
                SET disconnected_at = NOW(), last_seen_at = NOW()
                WHERE player_id = ? AND server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);
                stmt.setObject(2, serverSessionId);
                stmt.executeUpdate();
            }
        });
    }

    /**
     * Close all active sessions for this server run.
     * Called during graceful shutdown to avoid orphaned sessions.
     *
     * @return a Single emitting the number of sessions closed
     */
    public Single<Integer> closeAllSessions(UUID serverSessionId) {
        return storage.query(conn -> {
            String sql = """
                UPDATE player_sessions
                SET disconnected_at = NOW(), last_seen_at = NOW()
                WHERE server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, serverSessionId);
                return stmt.executeUpdate();
            }
        });
    }

    /**
     * Fix orphaned sessions from previous server runs (e.g., after a crash).
     * Sets disconnected_at = last_seen_at for any sessions not belonging to the current server.
     * Uses queryBlocking() so it's safe to call .blockingGet() from the main thread.
     *
     * @return a Single emitting the number of orphaned sessions that were fixed
     */
    public Single<Integer> fixOrphanedSessions(UUID currentServerSessionId) {
        return storage.query(conn -> {
            String sql = """
                UPDATE player_sessions
                SET disconnected_at = last_seen_at
                WHERE server_session_id != ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, currentServerSessionId);
                return stmt.executeUpdate();
            }
        });
    }

    /**
     * Find a player's UUID by their username (case-insensitive).
     * Returns the player_id from their most recent session.
     * Does not check online players - use {@link #resolvePlayerId} for that.
     */
    public Maybe<UUID> findPlayerIdByName(String username) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT player_id
                FROM player_sessions
                WHERE LOWER(username) = LOWER(?)
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, username);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getObject("player_id", UUID.class);
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Check if a username exists in the database (case-insensitive).
     * Used by nickname validation to prevent nicknames matching existing usernames.
     */
    public Single<Boolean> usernameExists(String username) {
        return storage.query(conn -> {
            String sql = "SELECT EXISTS(SELECT 1 FROM player_names WHERE LOWER(username) = LOWER(?))";

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, username);

                try (ResultSet rs = stmt.executeQuery()) {
                    rs.next();
                    return rs.getBoolean(1);
                }
            }
        });
    }

    /**
     * Resolves a player name to UUID, checking online players first then falling back to database.
     * Uses defer() to ensure Bukkit.getPlayer is called at subscription time (cold observable).
     *
     * @param playerName the player's username (case-insensitive)
     * @return Maybe emitting the player's UUID, or empty if not found
     */
    public Maybe<UUID> resolvePlayerId(String playerName) {
        return Maybe.defer(() -> {
            Player online = Bukkit.getPlayer(playerName);
            if (online != null) {
                return Maybe.just(online.getUniqueId());
            }
            return findPlayerIdByName(playerName);
        });
    }

    /**
     * Find a player's username by their UUID.
     * Returns the username from their most recent session.
     */
    public Maybe<String> findUsernameById(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT username
                FROM player_sessions
                WHERE player_id = ?
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getString("username");
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Find player usernames matching a prefix (case-insensitive).
     * Returns up to {@code limit} unique usernames from the player_names view.
     */
    public Flowable<String> findUsernamesByPrefix(String prefix, int limit) {
        return storage.queryFlowable(conn -> {
            String sql = """
                SELECT username
                FROM player_names
                WHERE LOWER(username) LIKE LOWER(?) || '%'
                ORDER BY username
                LIMIT ?
                """;

            List<String> usernames = new ArrayList<>();
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, prefix);
                stmt.setInt(2, limit);

                try (ResultSet rs = stmt.executeQuery()) {
                    while (rs.next()) {
                        usernames.add(rs.getString("username"));
                    }
                }
            }
            return usernames;
        });
    }

    /**
     * Get total lifetime online time for a player from the player_online_time view.
     * Returns the duration in seconds, or empty if the player has no sessions.
     */
    public Maybe<Long> getLifetimeOnlineTime(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT EXTRACT(EPOCH FROM online_time)::bigint AS seconds
                FROM player_online_time
                WHERE player_id = ?
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getLong("seconds");
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Get the start time of a player's current session.
     * Returns empty if the player has no active session for this server run.
     */
    public Maybe<Instant> getCurrentSessionStart(UUID playerId, UUID serverSessionId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT connected_at
                FROM player_sessions
                WHERE player_id = ? AND server_session_id = ? AND disconnected_at IS NULL
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);
                stmt.setObject(2, serverSessionId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getTimestamp("connected_at").toInstant();
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Get the IP address from a player's most recent session.
     */
    public Maybe<String> getLastIpAddress(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT remote_ip
                FROM player_sessions
                WHERE player_id = ?
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        return rs.getString("remote_ip");
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Get a player's username history with date ranges.
     * Uses the player_name_history view. Ordered newest first.
     */
    public Flowable<UsernameHistoryEntry> getUsernameHistory(UUID playerId) {
        return storage.queryFlowable(conn -> {
            String sql = """
                SELECT username, "from", "until"
                FROM player_name_history
                WHERE player_id = ?
                ORDER BY "from" DESC
                """;

            List<UsernameHistoryEntry> entries = new ArrayList<>();
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    while (rs.next()) {
                        var from = rs.getTimestamp("from").toInstant();
                        var untilTs = rs.getTimestamp("until");
                        var until = untilTs != null ? untilTs.toInstant() : null;
                        entries.add(new UsernameHistoryEntry(rs.getString("username"), from, until));
                    }
                }
            }
            return entries;
        });
    }

    /**
     * Get the date when a player first joined the server.
     */
    public Maybe<Instant> getFirstJoinDate(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT MIN(connected_at) AS first_join
                FROM player_sessions
                WHERE player_id = ?
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        var ts = rs.getTimestamp("first_join");
                        return ts != null ? ts.toInstant() : null;
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Get the last time a player was seen on the server.
     * Returns the most recent last_seen_at or disconnected_at timestamp.
     */
    public Maybe<Instant> getLastSeenDate(UUID playerId) {
        return storage.queryMaybe(conn -> {
            String sql = """
                SELECT COALESCE(disconnected_at, last_seen_at) AS last_seen
                FROM player_sessions
                WHERE player_id = ?
                ORDER BY connected_at DESC
                LIMIT 1
                """;

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setObject(1, playerId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        var ts = rs.getTimestamp("last_seen");
                        return ts != null ? ts.toInstant() : null;
                    }
                    return null;
                }
            }
        });
    }

    /**
     * Entry in a player's username history.
     *
     * @param username the username used during this period
     * @param from when this username started being used
     * @param until when this username stopped being used, or null if current
     */
    public record UsernameHistoryEntry(String username, Instant from, @Nullable Instant until) {}
}
